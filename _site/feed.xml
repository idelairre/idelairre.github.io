<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ian delairre</title>
    <description>Blog about web development, computer science, and probably indulgent philosophizing.</description>
    <link>https://github.com/idelairre/</link>
    <atom:link href="https://github.com/idelairre/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 02 Apr 2015 00:40:00 -0400</pubDate>
    <lastBuildDate>Thu, 02 Apr 2015 00:40:00 -0400</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>who am i? what am i doing here? why am i talking?</title>
        <description>&lt;p&gt;This blog constitutes my first foray into computer science. The topics here cover fundamentals like data structures, basic functions like sorts and the fundamental concepts of object oriented programming. I am by no means an expert and this constitutes a kind of excursion into totally foreign lands for me. If you want to know how a person with zero to no mathematical training understands computer science than you’ve come to the right place (you will no doubt hear some griping about the US education system and its consistent failure to teach math in a fair/interesting/useful manner). &lt;/p&gt;

&lt;p&gt;My background is in continental philosophy but my exposure to Francois Laruelle’s non-philosophy, graduate level academic trauma, and certain economic exigencies have pushed me in the direction of programming (and I think I’ve not only benefitted from it but perhaps saved myself).&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;In a week I will be graduating from General Assembly’s web development immersive program, however, it will be quite a journey for me to become a fully fledged programmer and computer scientist but I’m willing to do my due dilligence. If you find this AT ALL interesting than please leave comments, advice and so on. Wish me luck.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;if you want to see this sordid history documented checkout my old wordpress OR NOT: &lt;a href=&quot;https://differendkomplex.wordpress.com/&quot;&gt;https://differendkomplex.wordpress.com/&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Apr 2015 10:52:38 -0400</pubDate>
        <link>https://github.com/idelairre/2015/04/01/who-am-i-what-am-i-doing-here/</link>
        <guid isPermaLink="true">https://github.com/idelairre/2015/04/01/who-am-i-what-am-i-doing-here/</guid>
        
        
      </item>
    
      <item>
        <title>CS: trees, binary trees and tries</title>
        <description>&lt;p&gt;&lt;i&gt;Note: Most of this information was gained from a basic Google search and is presented here for the sake of distilling some basic concepts of computer science into an easily understandable form. This post concerns Tree data structures.&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;to do: fill out citations, show code snippets from GA exercises, finish tries section.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tree/shameless Laruelle plug:&lt;/strong&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;http://rosettacode.org/mw/images/d/d7/Fractal_tree.svg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Trees&lt;/h2&gt;
&lt;p&gt;A tree is a data structure that consists of a parent or root node which stores a data element and which possesses at least one child or branch. These child nodes in turn possess their own values and may have their own children (note: all nodes have 1 parent except for the root node which has 0).&lt;/p&gt;

&lt;p&gt;Trees are particularly useful for storing heirarchically arranged data. They are also very human readable since their visual organization resembles that of an actual tree. Further, for a relatively complex data structure (relative to a stack or queue) they can be traversed or &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Tree_traversal&quot;&gt;walked&lt;/a&gt;&quot; through relatively quickly, although this is highly dependent on their depth. Further, in the case of natural language processing, a large corpus of text can be stored as a tree which significantly reduces the query time required to find a sequence of words (as is the case with &lt;a href=&quot;http://en.wikipedia.org/wiki/N-gram&quot;&gt;&lt;i&gt;n&lt;/i&gt;-grams)&lt;/a&gt; and the memory requirements for its storage.&lt;/p&gt;

&lt;p&gt;Since this terminology can become somewhat convoluted I’ve provided a list of terms (note: these terms courtesy of the internet).&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tree terminology:&lt;/strong&gt;&lt;/p&gt;
&lt;li&gt;Node: stores a data element&lt;/li&gt;
&lt;li&gt;Parent: single node that directly precedes a node&lt;/li&gt;
&lt;li&gt;Child: one or more nodes that directly follow a node&lt;/li&gt;
&lt;li&gt;Ancestory: any node which precedes a node (itself, its parent, or an ancestory of its parent&lt;/li&gt;
&lt;li&gt;Descendent: any node which follows a node (itself, its child, or a descendent of its child&lt;/li&gt;
&lt;li&gt;Leaf (external node): node with no children&lt;/li&gt;
&lt;li&gt;Internal node: non-leaf node&lt;/li&gt;
&lt;li&gt;Siblings: nodes which share some parent&lt;/li&gt;
&lt;li&gt;Subtree: a node and all its descendents&lt;/li&gt;
&lt;li&gt;Ordered tree: a tree with definied order of children&lt;/li&gt;
&lt;li&gt;Binary tree: ordered tree with up to two children per node&lt;/li&gt;

&lt;p&gt;Practically, trees are implemented via recursion (where the function that creates the branch is called within the function itself) and a conditional sorting method.&lt;/p&gt;

&lt;h2&gt;Two types of trees&lt;/h2&gt;

&lt;p&gt;There are a variety of tree types, however, here we will address two simple types: the binary tree, which accordingly is a tree with a left and right branch, and a trie, which unhappily is far more complex (note: evidently the word &quot;trie&quot; comes from the word &quot;retrieval&quot; it can be pronounced either &quot;try&quot; or &quot;tree&quot; but definitively does not have a relationship with the word &quot;tri&quot; as in &quot;tricycle&quot;). For our purposes we will focus on tries for the rest of the article (although binary trees are certainly &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees&quot;&gt;varied&lt;/a&gt; and &lt;a href=&quot;http://mathworld.wolfram.com/BinaryTree.html&quot;&gt;complicated&lt;/a&gt; in their own right).&lt;/p&gt;

&lt;div class=&quot;picture-column-1&quot;&gt;
&lt;strong&gt;Binary tree:&lt;/strong&gt;

&lt;img width=&quot;330&quot; src=&quot;http://upload.wikimedia.org/wikipedia/commons/6/67/Sorted_binary_tree.svg&quot; /&gt;
&lt;/div&gt;
&lt;div class=&quot;picture-column-2&quot;&gt;
&lt;strong&gt;Trie:&lt;/strong&gt;
&lt;img width=&quot;355&quot; height=&quot;300&quot; src=&quot;http://i.stack.imgur.com/KhvoF.png&quot; /&gt;
&lt;/div&gt;
&lt;h2&gt;Tries&lt;/h2&gt;

&lt;p&gt;What is immediately distinguishing about a trie vs. a binary tree is that values are not stored at nodes but are rather indicated by the nodes position in the tree: “Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Values are normally not associated with every node, only with leaves and some inner nodes that correspond to keys of interest.”&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; Common applications for tries are for autocompletion or for storing predictive text.&lt;/p&gt;

&lt;p&gt;More on this later (with code snippets and more!)&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.amazon.com/Philosophy-Non-Philosophy-Univocal-Fran%C3%A7ois-Laruelle/dp/1937561127/ref=pd_bxgy_b_img_y&quot;&gt;http://www.amazon.com/Philosophy-Non-Philosophy-Univocal-Fran%C3%A7ois-Laruelle/dp/1937561127/ref=pd_bxgy_b_img_y&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Trie&quot;&gt;http://en.wikipedia.org/wiki/Trie&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Apr 2015 10:52:38 -0400</pubDate>
        <link>https://github.com/idelairre/2015/04/01/trees-binary-trees-and-tries/</link>
        <guid isPermaLink="true">https://github.com/idelairre/2015/04/01/trees-binary-trees-and-tries/</guid>
        
        
      </item>
    
      <item>
        <title>CS: bubble, merge, insertion, quick, and selection sorts</title>
        <description>&lt;p&gt;&lt;i&gt;Note: Most of this information was gained from a basic Google search and is presented here for the sake of distilling some basic concepts of computer science into an easily understandable form. This post concerns the variety of sort types.&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;to do: shorten bubble sort, finish selection sort (its just citations at the moment), show code snippets from GA exercises, get computer science degree&lt;/b&gt;&lt;/p&gt;

&lt;h2&gt;Bubble sort&lt;/h2&gt;

&lt;p&gt;The first sorting method we will deal with is the bubble sort. For something like this I immediately want to know why it is called a bubble sort. Fortunately the good folks at wikibooks have an answer: “The bubble sort gets its name because elements tend to move up into the correct order like bubbles rising to the surface.”&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; Interesting, so why does it have this behavior? The scary-smart brogrammer (who like myself could use some decent acne wash) who does the Harvard CS50 course explains: “the right most elements are garaunteed to be in their correct place.” He then takes the worst case scenario for sorting an array of numbers (the case that involves the most iterations) to demonstrate.&lt;/p&gt;

&lt;p&gt;If we have an array &lt;code&gt;[9, 6, 5, 3, 2]&lt;/code&gt; and we iterate once then we have &lt;code&gt;[6, 9, 5, 3, 2]&lt;/code&gt; on the next pass we have &lt;code&gt;[6, 5, 9, 3, 2]&lt;/code&gt;. We can already see the &lt;code&gt;9&lt;/code&gt; being passed to the right on each iteration so that it appears to “bubble” towards the right. &lt;/p&gt;

&lt;p&gt;On the next iteration we have &lt;code&gt;[6, 5, 3, 9, 2]&lt;/code&gt; and finally &lt;code&gt;[6, 5, 3, 2, 9]&lt;/code&gt;. On the next iteration it will start with &lt;code&gt;6&lt;/code&gt; thus, &lt;code&gt;[5, 6, 3, 2, 9]&lt;/code&gt; then &lt;code&gt;[5, 3, 6, 2, 9]&lt;/code&gt; and so on. This is clearly a very “expensive” operation (least not indicated because it was very tedious to type all those iterations). As such, its run time O of n is On&lt;sup&gt;2&lt;/sup&gt;, checking every element through each iteration.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bubble sort in action:&lt;/strong&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A “naive” or simple sorting algorithm would check all the elements of the array. However, knowing that the right most element is already sorted allows for a slight optimization. One can optimize again with flags and counters. At risk of repeating everything our clever bro says in the movie, I’ll allow you to check it out yourself.&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; Also checkout wikipedia’s &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort#Optimizing_bubble_sort&quot;&gt;article on optimizing bubble sorts.&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Merge Sort&lt;/h2&gt;

&lt;p&gt;A merge sort, as the name suggests, merges two sorted lists. Since there is a major time crunch on this assignment, I’ll again stick closely to the CS50 examples (this time featuring a brogrammer in an American Eagle polo his mom probably got for him in high school, but my God is he sexy smart).&lt;/p&gt;

&lt;p&gt;Supposing you have two already sorted lists &lt;code&gt;[4, 15, 16, 50]&lt;/code&gt; and &lt;code&gt;[8, 23, 42, 108]&lt;/code&gt;, since they are already sorted (with the smallest elements at the left of the list) you can take each first element of the two lists and compare whether one is larger than the other. &lt;code&gt;4&lt;/code&gt; is smaller so it  is entered as the first element of the new sorted list. The next task is to compare whether &lt;code&gt;8&lt;/code&gt; is larger or smaller than &lt;code&gt;15&lt;/code&gt;. Since &lt;code&gt;8&lt;/code&gt; is smaller it enters the sorted list as the second element and so forth.&lt;/p&gt;

&lt;p&gt;The basic pseudo code for this sorting algorithm is to compare the first two elements of each list and remove the smaller of the two. So after iterating through each list our final result should be &lt;code&gt;[4, 8, 15, 16, 23, 42, 50, 108]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merge sort in action:&lt;/strong&gt;&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Merge_sort_animation2.gif/220px-Merge_sort_animation2.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Assuming a less ideal situation where the same numbers are out of order in a single list, we need to adjust the algorithm. Here, our nerdcore brogrammer produces the list &lt;code&gt;[108, 15, 50, 4, 8, 42, 23, 16]&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;First we must split the lists in half until we have &lt;i&gt;n&lt;/i&gt; number lists for &lt;i&gt;n&lt;/i&gt; number elements: &lt;code&gt;[108][15][50][4][8][42][23][16]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Step two uses basically the same algorithm as before: the first two elements of two given lists are compared and the smaller one is entered as the first element of a new sorted list until all lists are of size 2: &lt;code&gt;[15, 108][4, 50][8, 42][16, 23]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Step three is to repeat this process until the lists are of size 4: &lt;code&gt;[4, 15, 50, 108][8, 16, 23, 42]&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Step four concludes the first pass by producing a single sorted list: &lt;code&gt;[4, 8, 15, 16, 23, 42, 50, 108]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So actually this is rather fast: O(&lt;i&gt;n&lt;/i&gt; log &lt;i&gt;n&lt;/i&gt;). But  the speed trade off are its memory requirements since it has to make new lists and store them in memory. Further, the use cases for merge sort may be limited since they tend to become inefficient for lists larger than 50 and are not universally faster than other algorithms with all unsorted lists.&lt;/p&gt;

&lt;p&gt;If you somehow found this useful than I don’t recommend watching the video, however, if you want to watch our brogrammers adorable blooper reel, definitely checkout the &lt;a href=&quot;https://www.youtube.com/watch?v=EeQ8pwjQxTM&quot;&gt;CS50 video&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Insertion sort: the most phallogocentric sorting method&lt;/h2&gt;

&lt;p&gt;An insertion sort iterates through an unsorted list one element at a time, grabbing it and determining its correct position in the sorted array. This is done by determing if it is larger or smaller than the first element in the sorted list. If it larger, it compares itself against the next element in the list until it finds an element larger than itself, in this case, it inserts itself in front of that element.&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;As such it is hardly an efficient algorithm. However, it can be faster than more advanced algorithms with very small data sets. Further, it is an incredibly simple program to write. Wikipedia notes that there is a three-line C version (which must be nothing short of a miracle).&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; Another advantage is that the sorted list is always sorted since it always puts the new element in the right order.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;insertion sort in action:&lt;/strong&gt;&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So much for insertion sort.&lt;/p&gt;

&lt;h2&gt;Quick sort&lt;/h2&gt;

&lt;p&gt;&lt;i&gt;Note: this sort method is really difficult to explain so I feel it is best to start with its terms. In this instance I find it useful to “bruteforce” my understanding with a lot of different examples. &lt;a href=&quot;https://www.youtube.com/watch?v=3OLTJlwyIqQ&quot;&gt;This video&lt;/a&gt; was particularly helpful.&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;quick sort terms:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pivot: the element being sorted&lt;/li&gt;
  &lt;li&gt;wall: the end of the list&lt;/li&gt;
  &lt;li&gt;current element: leftmost element&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Firstly, it is important to note that all elements to the right of the wall are bigger than then the the elements to the left.&lt;/p&gt;

&lt;p&gt;Quick sort takes the “pivot” element and compares its size against the element against the “wall” to see if it is larger than it. If it isn’t than it counts up the list until it finds such an element. When it finds it, it takes that element and puts it against the wall and takes the element previously against the wall and places it in the index of the swapped number, the wall then moves up to the next position in the list.&lt;/p&gt;

&lt;p&gt;If no other elements on the right side of the wall are larger then the algorithm takes the pivot element and swaps it with the first item to the right of the wall and the wall moves up accordingly.&lt;/p&gt;

&lt;p&gt;This algorithm is has the potential to be somewhat expensive in the worst, worst case scenario. Thus to increase the efficiency of this sort, one can use an inexpensive search to find the median value of the elements of the array to use as the pivot.&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;quick sort:&lt;/strong&gt;&lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;http://www.lisdn.com/attachments/2013/07/1_2013070813412612CE8.gif&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Selection Sort&lt;/h2&gt;

&lt;p&gt;“Selection sort is one way to sort an array of numbers. Data is divided into sorted and unsorted portions. One by one, the smallest values remaining in the unsorted portion are selected and swapped over to the sorted portion of the array.”&lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;First, scan the unsorted portion of the array to find the smallest value.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Swap that value with the first unsorted value – it is now part of the sorted subarray.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Repeat until there are no more values in the unsorted portion of the array.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“In both the best and worst cases, we’d have to compare each element to every other element in the unsorted subarray to ensure that the smallest value is selected on each iteration. As such, the selection sort algorithm takes n2 in the best and worst cases.”&lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Since the best and worst case runtimes of selection sort are equivalent, the expected runtime is Θ(n2)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;selection sort in action:&lt;/strong&gt;&lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Selection_sort_animation.gif/250px-Selection_sort_animation.gif&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort&quot;&gt;http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort#Analysis&quot;&gt;http://en.wikipedia.org/wiki/Bubble_sort#Analysis&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8Kp-8OGwphY&quot;&gt;https://www.youtube.com/watch?v=8Kp-8OGwphY&lt;/a&gt;. See also: &lt;a href=&quot;https://study.cs50.net/bubble_sort&quot;&gt;https://study.cs50.net/bubble_sort&lt;/a&gt;. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;http://en.wikipedia.org/wiki/Merge_sort&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;for the wonderful ambiguity of the term “ahead” or “behind” and some excellent intellectual penis jokes checkout Derrida’s &lt;a href=&quot;http://www.scribd.com/doc/39065838/Derrida-The-Postcard#scribd&quot;&gt;&lt;i&gt;Postcard&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;http://en.wikipedia.org/wiki/Insertion_sort&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort#Algorithm&quot;&gt;http://en.wikipedia.org/wiki/Insertion_sort#Algorithm&lt;/a&gt; &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=aQiWF4E8flQ&quot;&gt;https://www.youtube.com/watch?v=aQiWF4E8flQ&lt;/a&gt; &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:9&quot;&gt;
      &lt;p&gt;Note: the website I got this from is in Chinese &lt;a href=&quot;http://www.lisdn.com/&quot;&gt;http://www.lisdn.com/&lt;/a&gt; &lt;a href=&quot;#fnref:9&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:10&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://study.cs50.net/selection_sort&quot;&gt;https://study.cs50.net/selection_sort&lt;/a&gt; &lt;a href=&quot;#fnref:10&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:11&quot;&gt;
      &lt;p&gt;ibid. &lt;a href=&quot;#fnref:11&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:12&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;http://en.wikipedia.org/wiki/Selection_sort&lt;/a&gt; &lt;a href=&quot;#fnref:12&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Apr 2015 10:52:38 -0400</pubDate>
        <link>https://github.com/idelairre/2015/04/01/sorts-bubble-merge-insertion-quick-selection/</link>
        <guid isPermaLink="true">https://github.com/idelairre/2015/04/01/sorts-bubble-merge-insertion-quick-selection/</guid>
        
        
      </item>
    
      <item>
        <title>CS: abstract data types</title>
        <description>&lt;p&gt;&lt;i&gt;Note: Most of this information was gained from a basic Google search and is presented here for the sake of distilling some basic concepts of computer science into an easily understandable form. This post concerns Abstract Data Types or ADTs.&lt;/i&gt;&lt;/p&gt;
&lt;h2&gt;Queues&lt;/h2&gt;

&lt;p&gt;A queue is a simple data type which functions basically as a line (e.g., a line of cars at a tollbooth or line for a bank teller) where linearly or sequentially ordered elements are added on one end and retrieved at the other (another term for this type of data structure is “sequential collection”).&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; Operations on the queue are limited to two types: adding elements to the end (called enqueuing) and the removal of elements from the front (dequeuing).&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; As such, a queue is an example of a “First-In-First-Out (FIFO)” data structure where “the first element added to the queue will be the first element removed.” Queues are useful when only limited computing resources are available or can only handle a limited number of requests. In situations where system resources are scarce, the order of the data must be maintained and timeliness isn’t an issue, queues can be an appropriate way to process something like server requests.&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;queue:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Stacks&lt;/h2&gt;

&lt;p&gt;Queues are similar to stacks (they are both sequential collections and linear data structures) with the primary difference being that a stack is a “Last-In-First-Out” (LIFO) as opposed to FIFO data structure. Or rephrased, all the operations on a stack are done at the end or back of the collection whereas in a queue they are performed at the front and back. Again rephrased, in a queue, operations on the first element are processed first whereas, in a stack, operations are performed on the last or most recently added element first. Stacks are also limited to two operations: “pushing” and “popping.” A push adds an element to a collection, whereas a pop removes the last element that was added. Stacks can be implemented when task priority is important (e.g., from a user experience standpoint, the most recent request to a server should be processed first) or the tasks are event-based (where certain event-based operations should be processed immediately rather than queued).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stack:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/2/29/Data_stack.svg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Linked List&lt;/h2&gt;

&lt;p&gt;A more versatile data type (in the sense that operations can be performed at any place in the collection) is the linked list. Linked lists also possess the benefit that one does not need to specify a fixed size of the list (as is the case with arrays). As such it has more intuitive behavior than an array, i.e., adding elements to the list causes the list to get bigger. Since linked lists are comprised of nodes “linked” together in a sequence insertion and deletion can occur at any part of the collection by using the appropriate node as a reference (e.g., the C functions “insertBefore()” and “insertAfter()” which take a node as a parameter).&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; Linked lists can also be copied, searched and or merged with other lists into a larger list. Each node (with the exception of the last element) possesses a reference which links it to the next node in the sequence. Linked lists can be linked in a linear (where the last element has “null” for a reference) or circular fashion (where the last element has a reference to the first or header node) and singly and doubly linked. Singly linked lists can only be traversed in one direction (left to right) whereas doubly linked lists can be traversed in any direction. Linked lists are a preferable data type when:&lt;/p&gt;

&lt;li&gt;time predictability is crucial since the O of n is constant&lt;/li&gt;
&lt;li&gt;you don’t need to index the values of the array
when you don’t know how many items will be in your list&lt;/li&gt;
&lt;li&gt;when you need to insert items at any point in the list&lt;/li&gt;

&lt;p&gt;&lt;strong&gt;linked list:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mike-lipman.com/images/linked-list.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://sdmeta.gforge.inria.fr/FreeBooks/Joy/11.pdf&quot;&gt;http://sdmeta.gforge.inria.fr/FreeBooks/Joy/11.pdf&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Queue_(abstract_data_type)&quot;&gt;http://en.wikipedia.org/wiki/Queue_(abstract_data_type)&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7431054/when-where-how-should-queues-be-used&quot;&gt;http://stackoverflow.com/questions/7431054/when-where-how-should-queues-be-used&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://books.google.com/books?id=NdVS88muul4C&amp;amp;printsec=frontcover#v=onepage&amp;amp;q&amp;amp;f=false&quot;&gt;https://books.google.com/books?id=NdVS88muul4C&amp;amp;printsec=frontcover#v=onepage&amp;amp;q&amp;amp;f=false”&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 01 Apr 2015 10:52:38 -0400</pubDate>
        <link>https://github.com/idelairre/2015/04/01/abstract-data-types/</link>
        <guid isPermaLink="true">https://github.com/idelairre/2015/04/01/abstract-data-types/</guid>
        
        
      </item>
    
  </channel>
</rss>
